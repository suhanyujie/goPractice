package main

import (
	"fmt"
	"time"
)

func main() {
	c1 := make(chan int)
	go func () {
		c1<-1
	}()
	//c1 <- 2;
	fmt.Printf("hello world:%d...\n",<-c1)
	time.Sleep(1*time.Second)
}
/**
## 通道的基本操作
* 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
* 发送操作和接收操作中对元素值的处理都是不可分割的
* 发送操作在完全完成之前会被阻塞。接收操作也是如此。
* 这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。
* 另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。
*  一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。
* 另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。
* 如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。

### 问题 1：发送操作和接收操作在什么时候可能被长时间的阻塞？
* 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
* 相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。
* 对于非缓冲通道，，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。
* 相比之下，缓冲通道则在用异步的方式传递数据。
* 当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。
* 特别要注意，对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。

### 问题 2：发送操作和接收操作在什么时候会引发 panic？
* 对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。
* 另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。
* 注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true
* 因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
* 除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事

### 元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢？
* 可以使用引用类型的数据结构做实验。答案应该是浅复制

### 通道的长度代表着什么？它在什么时候会通道的容量相同？
* 通道的长度代表通道中当前有的元素个数，容量则代表初始化通道时期望的大小

## 参考
* 通道的基本操作 https://time.geekbang.org/column/article/14660

 */

